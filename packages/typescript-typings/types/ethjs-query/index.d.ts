declare module 'ethjs-query' {
  import BN from 'bn.js';

  export type Address = string;
  export type BlockHash = string;
  export type TxHash = string;
  export type BlockTag = 'latest' | 'pending' | 'earliest';
  export interface Event {
    transactionHash: string;
  }

  export interface Block<TX extends string | Transaction> {
    /** The block number. null when its pending block */
    number: BN;
    /** 32 Bytes - hash of the block. null when its pending block */
    hash: BlockHash;
    /** 32 Bytes - hash of the parent block */
    parentHash: BlockHash;
    /** 8 Bytes - hash of the generated proof-of-work. null when its pending block */
    nonce: string;
    /** 32 Bytes - SHA3 of the uncles data in the block */
    sha3Uncles: string;
    /** 256 Bytes - the bloom filter for the logs of the block. null when its pending block */
    logsBloom: string;
    /** 32 Bytes - the root of the transaction trie of the block */
    transactionsRoot: string;
    /** 32 Bytes - the root of the final state trie of the block */
    stateRoot: string;
    /** 32 Bytes - the root of the receipts trie of the block */
    receiptsRoot: string;
    // /** 20 Bytes - the address of the author of the block (the beneficiary to whom the mining rewards were given) */
    // author: Address;
    /** 20 Bytes - alias of author */
    miner: Address;
    /** integer of the difficulty for this block */
    difficulty: BN;
    /** integer of the total difficulty of the chain until this block */
    totalDifficulty: BN;
    /** the ‘extra data’ field of this block */
    extraData: string;
    /** integer the size of this block in bytes */
    size: BN;
    /** the maximum gas allowed in this block */
    gasLimit: BN;
    /** the total used gas by all transactions in this block */
    gasUsed: BN;
    /** the unix timestamp for when the block was collated */
    timestamp: BN;
    /** Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter */
    transactions: TX[];
    /** Array of uncle hashes */
    uncles: BlockHash[];
  }

  export interface TxEstimateOptions {
    to?: Address;
    from?: Address;
    value?: string | BN;
    gas?: number | BN;
    gasPrice?: BN;
    data: any;
  }

  export interface TransactionReceipt {
    /** hash of the block where this transaction was in. */
    blockHash: BlockHash;
    /** block number where this transaction was in. */
    blockNumber: BN;
    /** The contract address created, if the transaction was a contract creation, otherwise null. */
    contractAddress: null | Address;
    /** The total amount of gas used when this transaction was executed in the block */
    cumulativeGasUsed: BN;
    /** The amount of gas used by this specific transaction alone */
    gasUsed: BN;
    /** Array of log objects, which this transaction generated */
    logs: LogObject[];
    /** 256 Bytes - A bloom filter of logs/events generated by contracts during transaction execution. Used to efficiently rule out transactions without expected logs */
    logsBloom: string;
    // /** 32 Bytes - Merkle root of the state trie after the transaction has been executed (optional after Byzantium hard fork EIP609) */
    // root: string;
    /** ‘0x0’ indicates transaction failure , ‘0x1’ indicates transaction success. Set for blocks mined after Byzantium hard fork EIP609, null before */
    status: '0x0' | '0x1';
    /** hash of the transaction */
    transactionHash: TxHash;
    /** Integer of the transactions index position in the block */
    transactionIndex: BN;
  }

  export interface Transaction {
    /** hash of the transaction */
    hash: TxHash;
    /** the number of transactions made by the sender prior to this one */
    nonce: BN;
    /** hash of the block where this transaction was in. null when its pending */
    blockHash: null | BlockHash;
    /** block number where this transaction was in. null when its pending */
    blockNumber: null | BN;
    /** integer of the transactions index position in the block. null when its pending */
    transactionIndex: BN;
    /** address of the sender */
    from: Address;
    /** address of the receiver. null when its a contract creation transaction */
    to: Address;
    /** value transferred in Wei */
    value: BN;
    /** gas price provided by the sender in Wei */
    gasPrice: BN;
    /** gas provided by the sender */
    gas: BN;
    /** the data send along with the transaction. */
    input: string;
    /** the standardised V field of the signature. */
    v: string;
    /** the R field of the signature. */
    r: string;
    /** the S field of the signature. */
    s: string;
    // /** raw transaction data */
    // raw: Data;
    // /** creates contract hash */
    // creates: string;
  }
  export type DATA = string;
  export type QUANTITY = BN | number;
  export interface FilterOptions {
    /** (optional, default: "latest") Integer block number, or "latest" for the last mined block or "pending", "earliest" for not yet mined transactions. */
    fromBlock?: QUANTITY | BlockTag;
    /** (optional, default: "latest") Integer block number, or "latest" for the last mined block or "pending", "earliest" for not yet mined transactions. */
    toBlock?: QUANTITY | BlockTag;
    /** (optional) Contract address or a list of addresses from which logs should originate. */
    address?: Address;
    /** (optional) Array of 32 Bytes DATA topics. Topics are order-dependent. Each topic can also be an array of DATA with "or" options. */
    topics?: DATA[];
  }

  export interface PendingLogObject {
    /** true when the log was removed, due to a chain reorganization. false if its a valid log. */
    removed: boolean;
    /** integer of the log index position in the block. null when its pending log. */
    logIndex: null;
    /** integer of the transactions index position log was created from. null when its pending log. */
    transactionIndex: null;
    /** hash of the transactions this log was created from. null when its pending log. */
    transactionHash: null;
    /** hash of the block where this log was in. null when its pending. null when its pending log. */
    blockHash: null;
    /** the block number where this log was in. null when its pending. null when its pending log. */
    blockNumber: null;
    /** address from which this log originated. */
    address: Address;
    /** contains one or more 32 Bytes non-indexed arguments of the log. */
    data: string;
    topics: string[];
  }

  export interface MinedLogObject {
    /** true when the log was removed, due to a chain reorganization. false if its a valid log. */
    removed: boolean;
    /** integer of the log index position in the block. null when its pending log. */
    logIndex: BN;
    /** integer of the transactions index position log was created from. null when its pending log. */
    transactionIndex: BN;
    /** hash of the transactions this log was created from. null when its pending log. */
    transactionHash: TxHash;
    /** hash of the block where this log was in. null when its pending. null when its pending log. */
    blockHash: BlockHash;
    /** the block number where this log was in. null when its pending. null when its pending log. */
    blockNumber: BN;
    /** address from which this log originated. */
    address: Address;
    /** contains one or more 32 Bytes non-indexed arguments of the log. */
    data: string;
    topics: string[];
  }

  export type LogObject = MinedLogObject | PendingLogObject;

  class Eth {
    constructor(provider: any);

    accounts(): Promise<Address[]>;
    getBalance(account: Address): Promise<BN>;

    getBlockByHash(blockHash: BlockHash, fullTxs: true): Promise<null | Block<Transaction>>;
    getBlockByHash(blockHash: BlockHash, fullTxs: false): Promise<null | Block<string>>;

    getBlockByNumber(
      blockNumber: QUANTITY | BlockTag,
      fullTxs: true
    ): Promise<null | Block<Transaction>>;
    getBlockByNumber(
      blockNumber: QUANTITY | BlockTag,
      fullTxs: false
    ): Promise<null | Block<string>>;

    getTransactionReceipt(txHash: string): Promise<null | TransactionReceipt>;
    getTransactionByHash(txHash: string): Promise<null | Transaction>;
    blockNumber(): Promise<BN>;
    sign(account: Address, str: string): Promise<string>;

    getLogs(options: FilterOptions): Promise<LogObject[]>;
    newFilter(options: FilterOptions): Promise<string>;
    newBlockFilter(): Promise<string>;
    newPendingTransactionFilter(): Promise<string>;
    uninstallFilter(filterId: string): Promise<boolean>;
    getFilterChanges(filterId: string): Promise<BlockHash[] | TxHash[] | LogObject[]>;
    
    estimateGas(estimateTxOject: TxEstimateOptions): Promise<BN>;

    net_version(): Promise<string>;
  }

  export default Eth;
}
